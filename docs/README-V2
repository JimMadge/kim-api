#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the Common Development
# and Distribution License Version 1.0 (the "License").
#
# You can obtain a copy of the license at
# http://www.opensource.org/licenses/CDDL-1.0.  See the License for the
# specific language governing permissions and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each file and
# include the License file in a prominent location with the name LICENSE.CDDL.
# If applicable, add the following below this CDDL HEADER, with the fields
# enclosed by brackets "[]" replaced with your own identifying information:
#
# Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.
#
# CDDL HEADER END
#

#
# Copyright (c) 2017, Regents of the University of Minnesota.
# All rights reserved.
#
# Contributors:
#    Ryan S. Elliott
#    Ellad B. Tadmor
#

#
# Release: This file is part of the kim-api.git repository.
#


Experience with using and supporting the current kim-api-v1 package has shown
that the package's complexity (in terms of the number of different "modes of
operation"; e.g., neighbor lists: half, full, iterator, locator; NBCs: cluster,
miopbc, neigh_pure, neigh_rvec; etc.) makes it difficult for new users to
become competent kim-api code developers.  This also means that KIM Models will
only work with KIM-compliant codes that support the same modes of operation,
thereby limiting the utility of the kim-api as a standard.  Further, the
kim-api's complexity results in Model implementations that are overly intricate
due to developers' desire to support *all* modes of operation.  This experience
has led us to an approach that gives kim-api-v2 a dramatically simplified form
(at least, with regard to neighbor lists and NBCs), while still retaining a high
degree of flexibility.  Thus, in regard to feature design and selection for the
kim-api-v2 package, we have taken "simplicity" as a guiding principle.

The kim-api-v2 package adopts the following conventions:

(1) Neighbor Lists: Only full, random-access neighbor lists are supported.
    Support for multiple neighbor lists (with different cutoffs) has been
    added.

(2) Just one convention for describing a configuration of particles is used.
    There are "contributing" particles and "non-contributing" (ghost/padding)
    particles.  The particle status (contributing or non-contributing) is
    specified by an array of integers (as opposed to the kim-api-v1 approach of
    non-contributing particles having zero neighbors in the neighbor list).

(3) Clear definitions for Energy and Force: This is the same as in kim-api-v1,
    but we want to be very explicit about the definitions.  For a given
    configuration of particles, C, the configuration's energy, E^C, is the sum
    of the particle-energies for its *contributing* particles.  That is, E^C =
    \Sum_i E_i, where the sum is over just the *contributing* particles in C
    and E_i is the energy of particle i.  (We call E^C the "partial energy" in
    order to remind us that it is the energy of only the contributing
    particles.)  Similarly, the kim-api defines the "partial force" on particle
    j (contributing or non-contributing) in C as F^C_j = - \frac{\partial
    E^C}{\partial x_j}, where x_j is the position vector of particle j.  These
    definitions allow for a convenient implementation of domain-decomposition
    methods and periodic boundary conditions.


Some specifics about the kim-api-v2 package and its differences from kim-api-v1:

* A model is a method that provides a particular energy-per-particle
  function, E_i, and a "influence distance" value that identifies the
  influence distance over which a particle's energy function, E_i, depends on
  the positions of its neighboring particles.  (Note, this is not necessarily
  equal to the neighbor list cutoff radius used by a model.)


* A configuration, C, is a set of particles (Cp), their species names, their
  contributing status, and their coordinates (see below).  The set of
  contributing particles is Cc \subset Cp and the set of non-contributing
  particles is Cnc = Cp\Cc.


* A configuration's partialEnergy is defined as the sum of its contributing
  particles' energies: E^C = \sum_{i \in Cc} E_i.


* A configuration's partialForce on particle i (in Cp), f^C_i, is defined as
  the negative of the derivative of the configuration's partialEnergy with
  respect to the coordinates, x_i, of particle i: f^C_i = -\frac{\partial
  E^C}{\partial x_i}.  Note, that generally both contributing and
  non-contributing particles have non-zero partialForces.

  These definitions for E^C and F^C_i are useful for domain-decomposition (as
  well as other situations: periodic BC's, etc.).  As an example, consider a
  total energy and total force computation on an isolated block of 100
  particles.  Let this set of particles be denoted by Tp.  We can compute the
  total energy of the system and the total force on each particle using a
  single configuration.  In this case, the configuration is T, the set of
  particles is Tp, the set of contributing particles is Tc=Tp, and the set of
  non-contributing particles is Tnp=\emptyset.  Then, the total energy is
  E=E^T, and the total force on particle i \in Tp is f_i=f^T_i.  Next, let's
  consider how we can compute E and f_i using a two-domain decomposition.
  Partition Tp into two disjoint subsets, Ap and Bp.  That is, Ap \cap Bp =
  \emptyset and Ap \cup Bp = Tp.  Then define configuration C to have particles
  Cp=Tp with Cc=Ap and Cnp=Bp, and configuration D to have particles Dp=Tp with
  Dc=Bp and Dnp=Ap.  Then, E = E^C + E^D, and f_i = f^C_i + f^D_i.  In
  practice, one can get away with including only those non-contributing
  particles that fall within the "influence distance" of at least one
  contributing particle.


* Unified configuration description: A configuration consists of the following
  quantities (all are required):

  + numberOfParticles
       (int scalar) The number of particles (contributing and non-contributing)
       in the configuration.

  + particleSpeciesCodes[numberOfParticles]
       (int array) The species code (as defined by the model) of each particle.

  + particleContributing[numberOfParticles]
       (int array) 0/1 status of each particle in the configuration:
	"non-contributing" (0) or "contributing" (1).

  + coordinates[numberOfParticles,3]
       (double array) Cartesian coordinates of each particle.


* Required random-access, unordered full neighbor list with one or more
  cutoff values.  The Simulator is required to provide a set of neighbor lists
  that are fully consistent with the configuration description described
  above.  (In particular, the Model must---in principle---be able to
  independently construct its own *equivalent* neighbor list using just the
  configuration information described above.)  The Model will specify some
  number of cutoff values.  Each neighbor list must contain at least all
  particles within the corresponding cutoff distance (but may contain particles
  outside the cutoff distance).


* the "index" values (as in KIM_API_get_index()) have been eliminated, the
  argument names (e.g., KIM::ARGUMENT_NAME::coordinates) are used exclusively.


* FIXED parameters have eliminated.  Only changeable "FREE" parameters are
  "published".  (Fixed parameters now need to be stored in the Model Buffer,
  and are inaccessible to the Simulator.)


* For simplicity, we have eliminated explicit api tracking of argument shape
  and extent.  These values are defined as part of the api documentation.  All
  arguments must have fixed shape and extent values that are either given
  numbers or defined in terms of numberOfParticles.

  Model parameters are always taken to be one-dimensional arrays with a
  specified extent that must be defined by the model and communicated to the api
  through the get/set routines for parameters.  Thus, scalar parameters have
  extent 1.  Multidimensional array parameters are treated by the api as
  one-dimensional arrays with extent equal to the total number of values in the
  multidimensional array.


* kim-api-v2 memory management scheme

  Models must provide memory for their (1) "influence distance" value, (2)
  their array of "neighbor list cutoff distances", (3) their parameter
  arrays, and (4) the "model buffer" if used.

  Simulators must provide memory for (1) all "requiredByAPI" arguments, (2) all
  "required" arguments specified by the model, (3) any "optional" arguments
  used by the simulator, (4) the "simulator buffer" if used.

  It is no longer possible to request the kim-api to allocate memory for
  variables as was possible in kim-api-v1.  This created much confusion and
  is also undesirable from the perspective of code optimization.
