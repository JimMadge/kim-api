/*                                                                            */
/* CDDL HEADER START                                                          */
/*                                                                            */
/* The contents of this file are subject to the terms of the Common           */
/* Development and Distribution License Version 1.0 (the "License").          */
/*                                                                            */
/* You can obtain a copy of the license at                                    */
/* http://www.opensource.org/licenses/CDDL-1.0.  See the License for the      */
/* specific language governing permissions and limitations under the License. */
/*                                                                            */
/* When distributing Covered Code, include this CDDL HEADER in each file and  */
/* include the License file in a prominent location with the name             */
/* LICENSE.CDDL.                                                              */
/* If applicable, add the following below this CDDL HEADER, with the fields   */
/* enclosed by brackets "[]" replaced with your own identifying information:  */
/*                                                                            */
/* Portions Copyright (c) [yyyy] [name of copyright owner].                   */
/* All rights reserved.                                                       */
/*                                                                            */
/* CDDL HEADER END                                                            */
/*                                                                            */

/*                                                                            */
/* Copyright (c) 2017--2018, Regents of the University of Minnesota.          */
/* All rights reserved.                                                       */
/*                                                                            */
/* Contributors:                                                              */
/*    Ryan S. Elliott                                                         */
/*    Ellad B. Tadmor                                                         */
/*                                                                            */

/*                                                                            */
/* Release: This file is part of the kim-api.git repository.                  */
/*                                                                            */

/**
\page the_kim_api_package The %KIM API Package

The %KIM API package is a system-level library that aims to give computer
programmers the ability to write atomistic or molecular simulation programs
that can seamlessly interface with implementations of interatomic models,
regardless of the programming language (C, C++, FORTRAN 77, Fortran 90/95/2003,
Python, etc.) in which the codes are written.

This version of the %KIM API package is distributed under the [CDDL 1.0 Open
Source License](http://www.opensource.org/licenses/CDDL-1.0).

\section kim_api_features %KIM API Features

The current version of the %KIM API package supports the following features:

- **Programming Languages**: Currently supported programming languages include
  C, C++, FORTRAN 77, Fortran 90/95, Fortran 2003.

- **Best Practice API Design**: The guiding design principle for the %KIM API
    has been *simplicity*.  In addition to this, general API design *best
    practices* have been used.  These include: implementation hiding (pimpl
    idiom), loose coupling, minimal-completeness, easy to use (discoverable,
    difficult to misuse, consistent, orthogonal), static factory methods, use
    of namespaces, const-correctness, avoid the use of abbreviations, etc..

- **Language Idiom Support**: Wherever it makes sense and is possible the %KIM
    API supports common idioms of the native language.  For example, all C
    API routines that return an error status do so using the C function return
    value.  For Fortran, all such API routines are SUBROUTINES and have their
    final argument as an error status.

- **Extensible, Strongly-Typed Enumerations**: The %KIM API implements a set of
    typed constants for each category of entity that it defines (DataType,
    LanguageName, Numbering, SpeciesName, LengthUnit, EnergyUnit, ChargeUnit,
    TemperatureUnit, TimeUnit, ArgumentName, CallbackName, SupportStatus).
    This allows for backward-compatible additions to the enumerations in future
    versions of the %KIM API.  Further, the strong-typing greatly facilitates
    debugging.

- **Numbering Origin Support**: Support for automatic translation between
  zero-based numbering of particles (C-style numbering beginning with zero) and
  one-based numbering (Fortran-style numbering beginning with one).

- **Data Communication**: Communication of an arbitrary number of *arguments*
  between a *Model* (interatomic potential) and a *Simulator* (simulation code
  that uses a Model).

- **Data types**: integer and double.

  Each of the data types can be used to create multi-dimensional array
  arguments that are exchanged between Models and Simulators.  The %KIM API
  standard defines the dimension and extent of these arrays for each argument.
  However, this information is not discoverable at run-time.  Thus, it is left
  to the programmer to ensure that the correct values are used.

  Currently, the %KIM API does not define any (more complex) data structures.
  However, in the future (as the need arises, and in consultation with the
  atomistic and molecular simulation community) additional data types and data
  structures may be introduced.

- **Physical Units**: The %KIM API standard defines the physical units for each
  argument exchanged between a Model and Simulator.  A simulator provides a set
  of *requested units* to define a unit system and a model either accepts this
  unit system (and performs appropriate unit conversions for its parameters),
  or it rejects the request and reports the unit system to be used.

- **Neighbor lists**: Neighbor list routines are expected to be provided by the
  calling Simulator.  All neighbor lists are full, unsorted lists that must
  contain all particles within the specified cutoff distance (but may contain
  additional particles).  A model must request one or more neighbor lists, each
  with an associated cutoff distance.  (Cutoff distances are typically
  distinct, but may repeat.  Repeated cutoff distances allow a model to
  simultaneously access the neighbors of multiple particles without needing to
  make copies of the neighbor list(s).)  A simulator must provide all such
  requested lists.

- **Particle Species**: The %KIM API provides the ability to designate the
  physical species of each particle in a simulation.  Currently, only one
  identifier is provided for each element in the periodic table.  In the future
  support for Models that require multiple types of each element may be added.

- **Model Parameters**: The %KIM philosophy views a *Model* as a well-defined
  computational code that includes specific values for all parameters needed to
  perform an actual computation.  However, it is often useful to explore how a
  Model's predictions vary as the values of its parameters are varied.  For
  this reason, the %KIM API allows a Model to (optionally) "publish" its
  parameters so that a Simulator may modify them during the course of a
  simulation.

- **Model Drivers**: The %KIM API package provides the ability to create Model
  Driver routines.  A Model for a given material can be created which uses an
  existing Model Driver by providing a file or files with the appropriate
  parameter values for the material of interest.

- **Logging capabilities**: The %KIM API package provides a full-featured
  logging capability that facilitates the identification and debugging of
  errors.  In addition to built-in support for logging within Model codes, the
  %KIM API also provides access to logging capabilities for general use by
  Simulator codes.

- **Semantic Versioning**: The %KIM API package conforms to the [Semantic
  Versioning 2.0.0](https://semver.org) standard.  This standard is useful
  because its version numbers and the way they change convey meaning about the
  underlying code and what has been modified from one version to the next.  In
  addition, the %KIM API provides basic tools for comparing and parsing Semantic
  Version strings.

For more details on the difference between version 1 and version 2 of the
kim-api package, see \ref version2_differences.

\section theory Theory

This section describes the concepts and definitions upon which the %KIM API
standard is based.

At the highest level there are "Simulators" and "Models".  At the conceptual
level, a %KIM Model is something that defines an energy-per-particle function,
\f$E_i\f$, and an "influence distance", \f$r_{\text{infl}}\f$, that identifies
the particle separation range over which \f$E_i\f$ depends on the position of
its neighboring particles.  (Note, this is not necessarily equal to the
neighbor list cutoff radius used by a model.)  A %KIM Model is defined for a
specific material system (a specific set of particle species: e.g., Al, Ni, and
Cu) and contains all parameter values necessary for evaluating \f$E_i\f$ for
any configuration containing particles of the supported species.  A %KIM Model
will, typically, also have the ability to compute other quantities related to
the energy-per-particle, such as the force on a particle or the particle's
virial.

At the conceptual level, a %KIM Simulator is something that performs a numerical
simulation based on the energy, forces, etc. of a set of particles.  This could
be a molecular dynamics simulation, a monte carlo simulation, or other similar
simulation technique.  A %KIM Simulator treats a %KIM Model as a black box.  It
constructs an atomistic "Configuration" of interest and passes this
configuration to a %KIM Model along with a list of quantities (energy, force,
virial, etc.) to be computed.  The model then performs the requested
computation and passes the results back to the simulator.  Once the simulator
has received the model's results it may use these values to advance its
simulation and update the atomistic configuration.  Typically, this sequence of
events is repeated in an iterative process until the simulator determines it
has reached convergence or a predetermined stopping condition is achieved.

The purpose of the %KIM API is to coordinate the information exchange between
%KIM Simulators and %KIM Models.  It does this through the definition of various
concepts and quantities, and by providing a set of subroutines that facilitate
the necessary communication between simulators and models.

Of central importance to this process is the definition of an atomistic
"Configuration", \f$\mathcal{C}\f$.  Abstractly, a configuration consists of a
set of particles \f$C_p\f$ and their associated data.  For each particle \f$i
\in C_p\f$, the following additional data must be defined.

  -# The particle's species (H, He, Li, etc.).

  -# The particle's position vector \f$\mathbf{r}^{(i)} = r^{(i)}_j
     \mathbf{e}_j = r^{(i)}_1 \mathbf{e}_1 + r^{(i)}_2 \mathbf{e}_2 + r^{(i)}_3
     \mathbf{e}_3,\f$ where \f$\mathbf{e}_j, \; j=1,2,3\f$ are unit vectors
     along the global fixed Cartesian coordinate system \f$x\f$, \f$y\f$, and
     \f$z\f$ directions, respectively.

  -# The particle's "Contributing Status", which is either "contributing" or
     "non-contributing".  Non-contributing particles exist as part of the
     configuration only to provide the proper environment for the contributing
     particles.  Thus, non-contributing particles (sometimes called "ghost" or
     "padding" particles) can be thought of as providing the appropriate
     boundary conditions for the configuration.

Before proceeding further, introduce the notation \f$\mathbf{r}^{(j,i)} \equiv
\mathbf{r}^{(j)} - \mathbf{r}^{(i)}\f$ for the relative position vector from
particle \f$i\f$ to particle \f$j\f$, and the notation \f$r^{(j,i)}\f$ for the
magnitude of the vector \f$\mathbf{r}^{(j,i)}\f$.  Note that \f$r^{(j,i)} =
r^{(i,j)}\f$ and these are simply two different notations for the same
quantity.  However, when taken as a function of particle position vectors,
\f$r^{(j,i)} = \bar{r}^{(j,i)}(\mathbf{r}^{(j)}, \mathbf{r}^{(i)}) \equiv \|
\mathbf{r}^{(j)} - \mathbf{r}^{(i)}\|\f$, there is a difference.  In
particular,

\f[
\frac{\partial \bar{r}^{(j,i)}}{\partial \mathbf{r}^{(j)}} = -
\frac{\partial \bar{r}^{(i,j)}}{\partial \mathbf{r}^{(j)}}.
\f]

Returning to the definition and description of a configuration, a
configuration's set of particles may be partitioned into two disjoint sets: The
set of contributing particles \f$C_{cp}\f$, and the set of non-contributing
particles \f$C_{ncp}\f$.  So that

\f[
C_{p} = C_{cp} \cup C_{ncp} \quad \text{and} \quad C_{cp} \cap C_{ncp}
= \emptyset.
\f]

For a particle \f$i \in C_p\f$, define the particle's ("punctured") influence
neighborhood, \f$\mathcal{N}^{(i)}_{r_\text{infl}}\f$, as the subset of
particles (not including the particle, itself) in the configuration that are
located no more than \f$r_{\text{infl}}\f$ away from particle \f$i\f$.  That
is,

\f[
\mathcal{N}^{(i)}_{r_\text{infl}} \equiv \{ j \in C_p \;|\;
0 < r^{(j,i)} \le r_{\text{infl}} \}.
\f]

Finally, define the closure of the particle's influence neighborhood,
\f$\bar{\mathcal{N}}^{(i)}_{r_{\text{infl}}}\f$:

\f[
\bar{\mathcal{N}}^{(i)}_{r_{\text{infl}}} \equiv
\mathcal{N}^{(i)}_{r_{\text{infl}}} \cup
\{i\}.
\f]

With the above definitions, it is possible to more specifically identify the
functional dependence for a %KIM Model's energy-per-particle function,
\f$E_i\f$:

\f[
E_i = \bar{E}_i(\mathbf{r}^{(j)} \;|\; j \in
\bar{\mathcal{N}}^{(i)}_{r_{\text{infl}}}).
\f]

In fact, due to the principle of material frame indifference, this function can
only be a function of the *distances* between these particles:

\f[
E_i = \tilde{E}_i( r^{(j,k)} \;|\; j,k \in
\bar{\mathcal{N}}^{(i)}_{r_{\text{infl}}})
.
\f]

It is usually most convenient to work with the function of position vectors,
\f$\bar{E}_i(\mathbf{r}^{(j)})\f$.  However, in some cases it is advantageous
to work with the function of distances, \f$\tilde{E}_i(r^{(j,k)})\f$.  When the
distinction is unimportant, use the unaccented notation, \f$E_i\f$, will be
used.

Now a configuration's "Partial Energy" may be defined as the sum of its
contributing particles' energies:

\f[
E^\mathcal{C} = \sum_{i \in C_{cp}} E_i.
\f]

From this definition of the configuration's partial energy, a set of additional
quantities may be derived that are often of interest in simulations.

First, define formally, the configuration's "Partial Particle Energy" for
particle \f$i\f$, \f$E^{\mathcal{C}}_i\f$, as simply the model's
energy-per-particle value for contributing particles and zero for
non-contributing particles,

\f[
E^{\mathcal{C}}_i \equiv
\begin{cases}
E_i, & i \in C_{cp},\\
0,   & i \in C_{ncp}.
\end{cases}
\f]

Second, the configuration's "Partial Force" on particle \f$j\f$,
\f$\mathbf{f}^{\mathcal{C}(j)}\f$, is defined as the negative of the derivative
of the configuration's partial energy with respect to the particle's position
vector:

\f[
\mathbf{f}^{\mathcal{C}(j)} \equiv - \frac{\partial E^{\mathcal{C}}}{\partial
\mathbf{r}^{(j)}}, \quad j \in C_{p}.
\f]

Note that, in general, *every* particle (both contributing and
non-contributing) has a partial force.  As a special case, consider a
configuration, \f$\mathcal{C}^i\f$, equivalent to \f$\mathcal{C}\f$ except that
only particle \f$i\f$ is contributing.  In this case, the partial forces are

\f[
\mathbf{f}^{\mathcal{C}^i(j)} =
\begin{cases}
-\frac{\partial \bar{E}_i}{\partial \mathbf{r}^{(j)}} & j \in
\mathcal{N}^{(i)}_{r_{\text{infl}}}, \\
0, & \text{otherwise}.
\end{cases}
\f]

This can be thought of as the force on particle \f$j\f$ due to particle
\f$i\f$.  With this notation, it is possible to obtain the identity

\f[
\mathbf{f}^{\mathcal{C}(j)} = \sum_{i \in C_{cp}}
\mathbf{f}^{\mathcal{C}^i(j)}.
\f]

Third, the configuration's "Partial Particle Virial" tensor for contributing
particle \f$i \in C_{cp}\f$, \f$\mathbf{V}^{\mathcal{C}(i)}\f$, is defined in
terms of the derivative of its per-particle-energy function:

\f[
\mathbf{V}^{\mathcal{C}(i)} \equiv \sum_{j \in
\mathcal{N}^{(i)}_{r_{\text{infl}}}}
\frac{\partial \bar{E}_i}{\partial \mathbf{r}^{(j)}}
\otimes
\mathbf{r}^{(j)}
=
\sum_{j \in \mathcal{N}^{(i)}_{r_{\text{infl}}}}
-\mathbf{f}^{\mathcal{C}^i(j)}
\otimes
\mathbf{r}^{(j)}
=
-\sum_{j \in \mathcal{N}^{(i)}_{r_{\text{infl}}}}
\mathbf{f}^{\mathcal{C}^i(j)}
\otimes
\mathbf{r}^{(j)}
.
\f]

The partial particle virial is zero for non-contributing particles.  That is,
\f$\mathbf{V}^{\mathcal{C}(i)} = \mathbf{0}\f$ for \f$i \in C_{ncp}\f$.

Fourth, the configuration's "Partial Virial" tensor,
\f$\mathbf{V}^{\mathcal{C}}\f$, is the sum of its partial particle virial
tensors.

\f[
\mathbf{V}^{\mathcal{C}} \equiv \sum_{i \in C_{p}}
\mathbf{V}^{\mathcal{C}(i)}.
\f]

Note that an equivalent expression for the partial virial tensor is given by

\f[
\mathbf{V}^{\mathcal{C}} = - \sum_{i \in C_{p}}
\mathbf{f}^{\mathcal{C}(i)}
\otimes
\mathbf{r}^{(i)}.
\f]

Fifth and finally, the configuration's "Partial Hessian",
\f$\mathbf{H}^{\mathcal{C}}\f$, is defined by

\f[
\mathbf{H}^{\mathcal{C}} \equiv
\begin{bmatrix}
H^{\mathcal{C}(0,0)}_{1,1} & H^{\mathcal{C}(0,0)}_{1,2} &
H^{\mathcal{C}(0,0)}_{1,3} & H^{\mathcal{C}(0,1)}_{1,1} &
H^{\mathcal{C}(0,1)}_{1,2} & H^{\mathcal{C}(0,1)}_{1,3} & \cdots \\
H^{\mathcal{C}(0,0)}_{2,1} & H^{\mathcal{C}(0,0)}_{2,2} &
H^{\mathcal{C}(0,0)}_{2,3} & H^{\mathcal{C}(0,1)}_{2,1} &
H^{\mathcal{C}(0,1)}_{2,2} & H^{\mathcal{C}(0,1)}_{2,3} & \cdots \\
H^{\mathcal{C}(0,0)}_{3,1} & H^{\mathcal{C}(0,0)}_{3,2} &
H^{\mathcal{C}(0,0)}_{3,3} & H^{\mathcal{C}(0,1)}_{3,1} &
H^{\mathcal{C}(0,1)}_{3,2} & H^{\mathcal{C}(0,1)}_{3,3} & \cdots \\
H^{\mathcal{C}(1,0)}_{1,1} & H^{\mathcal{C}(1,0)}_{1,2} &
H^{\mathcal{C}(1,0)}_{1,3} & H^{\mathcal{C}(1,1)}_{1,1} &
H^{\mathcal{C}(1,1)}_{1,2} & H^{\mathcal{C}(1,1)}_{1,3} & \cdots \\
H^{\mathcal{C}(1,0)}_{2,1} & H^{\mathcal{C}(1,0)}_{2,2} &
H^{\mathcal{C}(1,0)}_{2,3} & H^{\mathcal{C}(1,1)}_{2,1} &
H^{\mathcal{C}(1,1)}_{2,2} & H^{\mathcal{C}(1,1)}_{2,3} & \cdots \\
H^{\mathcal{C}(1,0)}_{3,1} & H^{\mathcal{C}(1,0)}_{3,2} &
H^{\mathcal{C}(1,0)}_{3,3} & H^{\mathcal{C}(1,1)}_{3,1} &
H^{\mathcal{C}(1,1)}_{3,2} & H^{\mathcal{C}(1,1)}_{3,3} & \cdots \\
\vdots & \vdots & \vdots & \vdots & \vdots & \vdots & \ddots
\end{bmatrix},
\f]

where \f$H^{\mathcal{C}(i,j)}_{m,n} \equiv \frac{\partial^2
E^{\mathcal{C}}}{\partial r^{(i)}_m \partial r^{(j)}_n}\f$ and, to be explicit,
zero-based particle numbering has been used.

## Domain Decomposition

The definitions of a configuration's partial energy, forces, virial, and
hessian are designed to allow for easy (and low communication) parallel
computation via domain decomposition.  This section presents a simple example
that illustrates how this works.

Start with a configuration of particles corresponding to a finite strip of a
centered square lattice.

\image html  square-lattice-configuration-1.jpg
\image latex square-lattice-configuration-1.pdf

The total energy of the system and the total force on each particle can be
computed using a single configuration.  In this case, the configuration is
\f$\mathcal{T}\f$, the set of particles is \f$T_p\f$, the set of contributing
particles is \f$T_{cp} = T_p\f$, and the set of non-contributing particles is
\f$T_{np}=\emptyset\f$.  Then, the total energy is \f$E=E^\mathcal{T}\f$, and
the total force on particle \f$i \in T_p\f$ is
\f$\mathbf{f}^{(i)}=\mathbf{f}^{\mathcal{T}(i)}\f$.  Next, it is shown how to
compute \f$E\f$ and \f$\mathbf{f}^{(i)}\f$ using a two-domain decomposition.

Partition \f$T_p\f$ into two disjoint subsets, \f$A_p\f$ and \f$B_p\f$. That
is, \f$A_p \cap B_p = \emptyset\f$ and \f$A_p \cup B_p = T_p\f$.

\image html square-lattice-configuration-2.jpg
\image latex square-lattice-configuration-2.pdf


Then define configuration \f$\mathcal{C}\f$ to have particles \f$C_p=T_p\f$
with \f$C_{cp}=A_p\f$ and \f$C_{ncp}=B_p\f$, and configuration
\f$\mathcal{D}\f$ to have particles \f$D_p=T_p\f$ with \f$D_{cp}=B_p\f$ and
\f$D_{ncp}=A_p\f$.  Then,

\f[
E = E^\mathcal{C} + E^\mathcal{D},
\f]
and
\f[
\mathbf{f}^{(i)} = \mathbf{f}^{\mathcal{C}(i)} +
\mathbf{f}^{\mathcal{D}(i)}.
\f]

In practice, one can get away with including only those non-contributing
particles that fall within the "influence distance" of at least one
contributing particle.


\section implementation_theory Implementation Theory

This section describes some of the high-level approaches used to implement the
%KIM API theory described in Section \ref theory.

In code, a model (or model driver) consists of four routines which perform
specific tasks.  The first is the *ModelCreate* (or *ModelDriverCreate*)
routine, which performs all necessary initialization tasks.  The second is the
*ModelCompute* routine, which performs the core computational tasks.  The third
is the *ModelRefresh* routine, which performs any necessary updates after a
simulator makes changes to the model's parameters (if this is supported).  The
fourth is the *ModelDestroy* routine, which performs all necessary finalization
tasks.

To interact with a model, a simulator creates a model object (which, in part,
includes execution of the model's *ModelCreate* routine).  Using this object,
the simulator provides a set of "Arguments" to the model's *ModelCompute*
function.  There are input arguments that include the various components that
make up a configuration (number of particles, particle position vectors, etc.).
And, there are output arguments that include the quantities (like partial
energy and partial forces), defined in Section \ref theory, associated with the
configuration.  There are also "Callback" functions (such as a function to get
a particle's neighbor list) that the simulator provides for use by the model.

The %KIM API provides a list of all arguments and callbacks defined as part of
the official API.  Each argument and callback has a "Support Status" which can
be one of four values: *requiredByAPI*, *notSupported*, *required*, or *optional*.
A model specifies a support status value for every argument defined by the %KIM
API.  It is the responsibility of the simulator to use the model object
interface to determine the support status of each argument and to use this
information to determine if the model is capable of performing the desired
computation.

Here lists of each input argument, output argument, and callback are provided.
To be explicit, below zero-based particle numbering is used where necessary.

Input argument table:
Argument Name         | Unit   | Data Type | Extent                | Memory Layout                                                      | Valid Support Statuses (bold -- default) |
--------------------- | ------ | --------- | --------------------- | ------------------------------------------------------------------ | ---------------------------------------- |
numberOfParticles     | N/A    | double    | 1                     |                                                                    | **requiredByAPI**                        |
particleSpeciesCodes  | N/A    | integer   | numberOfParticles     | \f$sc^{(0)}, sc^{(1)}, \dots\f$                                    | **requiredByAPI**                        |
particleContributing  | N/A    | integer   | numberOfParticles     | \f$c^{(0)}, c^{(1)}, \dots\f$                                      | **requiredByAPI**                        |
coordinates           | length | double    | numberOfParticles * 3 | \f$r^{(0)}_1, r^{(0)}_2, r^{(0)}_3, r^{(1)}_1, r^{(1)}_2, \dots\f$ | **requiredByAPI**                        |

- numberOfParticles is the number of particles (contributing and
non-contributing) in the configuration.

- particleSpeciesCodes contains integer codes (as defined by the model)
specifying the species of each particle.  For example, if the model defines the
mapping Cu \f$\leftrightarrow 1\f$, Al \f$\leftrightarrow 2\f$, and Ni
\f$\leftrightarrow 3\f$, then \f$sc^{(0)} = 3, sc^{(1)} = 1, sc^{(2)} = 2, \dots\f$
means that particle 0 is a nickel atom, particle 1 is a copper atom, particle 2
is an aluminum atom, etc.

- particleContributing contains the contributing/non-contributing status
of each particle.  Particle \f$i\f$ is contributing if \f$c^{(i)} = 1\f$ and
non-contributing if \f$c^{(i)} = 0\f$.

- coordinates contains the Cartesian components of the particles' position
  vectors, \f$\mathbf{r}^{(i)} = r^{(i)}_1 \mathbf{e}_1 + r^{(i)}_2
  \mathbf{e}_2 + r^{(i)}_3 \mathbf{e}_3\f$.

Output argument table:
Argument Name         | Unit                       | Data Type | Extent                | Memory Layout                                                           | Valid Support Statuses (bold -- default) |
--------------------- | -------------------------- | --------- | --------------------- | ----------------------------------------------------------------------- | ---------------------------------------- |
partialEnergy         | energy                     | double    | 1                     |                                                                         | required, optional, **notSupported**     |
partialForces         | force                      | double    | numberOfParticles * 3 | \f$f^{\mathcal{C}(0)}_1, f^{\mathcal{C}(0)}_2, f^{\mathcal{C}(0)}_3, f^{\mathcal{C}(1)}_1, f^{\mathcal{C}(1)}_2\dots\f$ | required, optional, **notSupported**     |
partialParticleEnergy | energy                     | double    | numberOfParticles     | \f$E^{\mathcal{C}(0)}, E^{\mathcal{C}(1)}, E^{\mathcal{C}(2)}, \dots\f$ | required, optional, **notSupported**     |
partialVirial         | energy                     | double    | 6                     | \f$V^{\mathcal{C}}_{11}, V^{\mathcal{C}}_{22}, V^{\mathcal{C}}_{33}, V^{\mathcal{C}}_{23}, V^{\mathcal{C}}_{32}, V^{\mathcal{C}}_{13}\f$ | required, optional, **notSupported**     |
partialParticleVirial | energy                     | double    | numberOfParticles * 6 | \f$\mathbf{V}^{\mathcal{C}(0)}, \mathbf{V}^{\mathcal{C}(1)}, \mathbf{V}^{\mathcal{C}(2)}, \dots\f$ | required, optional, **notSupported**     |
partialHessian        | energy * length\f$^{-2}\f$ | double    | numberOfParticles * (numberOfParticles + 1)/ 2 | "upper-triangular column packed storage" | required, optional, **notSupported**     |

- partialEnergy is the configuration's partial energy \f$E^{\mathcal{C}}\f$.

- partialForces contains the partial force vector for each particle,
  \f$\mathbf{f}^{\mathcal{C}(i)} = f^{\mathcal{C}(i)}_1 \mathbf{e}_1 +
  f^{\mathcal{C}(i)}_2 \mathbf{e}_2 + f^{\mathcal{C}(i)}_3 \mathbf{e}_3\f$.

- partialParticleEnergy contains the partial particle energy for each particle,
  \f$E^{\mathcal{C}(i)}\f$.

- partialVirial is the configuration's partial virial tensor,
  \f$\mathbf{V}^{\mathcal{C}}\f$.

- partialParticleVirial contains the partial particle virial tensor for each
  particle, \f$\mathbf{V}^{\mathcal{C}(i)}\f$.

- partialHessian contains the partial Hessian tensor
  \f$\mathbf{H}^{\mathcal{C}}\f$ in [upper-triangular column packed
  storage](http://www.netlib.org/lapack/lug/node123.html) format.



Callback table:
Callback Name         | Valid Support Statuses (bold -- default) |
--------------------- | ---------------------------------------- |
GetNeighborList       | **requiredByAPI**                        |
ProcessDEDrTerm       | required, optional, **notSupported**     |
ProcessD2EDr2Term     | required, optional, **notSupported**     |

- GetNeighborList is a callback function that allows a model to obtain the
  list of neighbors of a particle.  The model may request any number of
  neighbor lists with different (or equal) cutoff distances.  The
  GetNeighborList callback function must support the return of the appropriate
  list of neighbors.  The returned list of neighbors consists of a
  contiguous-in-memory list of integers corresponding to an unordered full list
  of a particle's neighbors.  Each such neighbor list must contain at least all
  particles within the corresponding cutoff distance of the specified
  particle.  (However, the returned list may contain particles beyond the
  cutoff distance.)  Neighbor lists provided by the simulator must be
  consistent with the configuration coordinates.  In particular, the model
  must, in principle, be able to independently construct its own equivalent
  neighbor list using just the particle coordinates.

- ProcessDEDrTerm is a callback function that allows for access to the
  derivatives of the configuration's partial energy, \f$E^{\mathcal{C}}\f$,
  with respect to all pair-distances, \f$r^{(i,j)}, i,j \in C_{p}\f$.  That is,
  it allows the model to communicate the values of \f$\frac{\partial
  E^{\mathcal{C}}}{partial r^{(i,j)}}\f$ to the simulator.

  These quantities can be used to compute many quantities of interest
  associated with the configuration.  For example, it is possible to
  independently compute the partial virial from this information using the
  formula

  \f[
  \mathbf{V}^{\mathcal{C}} = \sum_{i \in C_p} \mathbf{V}^{\mathcal{C}(i)}
  = \sum_{i \in C_p} \sum_{j \in \mathcal{N}^{(i)}_{r_{\text{infl}}}}
  \frac{\bar{E}_i}{\partial \mathbf{r}^{(j)}} \otimes \mathbf{r}^{(j)}
  = \sum_{i \in C_p} \sum_{j \in \mathcal{N}^{(i)}_{r_{\text{infl}}}} \;\;
  \sum_{k \not= j; \; k \in \bar{\mathcal{N}}^{(i)}_{r_{\text{infl}}}}
  \frac{\partial \tilde{E}_i}{\partial r^{(j,k)}}
  \frac{\partial \bar{r}^{(j,k)}}{\partial \mathbf{r}^{(j)}}
  \otimes \mathbf{r}^{(j)}.
  \f]

- ProcessD2EDr2Term is a callback function that allows for access to the second
  derivatives of the configuration's partial energy, \f$E^{\mathcal{C}}\f$,
  with respect to all pair-distances, \f$r^{(i,j)}, i,j \in C^{p}\f$.  That is,
  it allows the model to communicate the values of \f$\frac{\partial^2
  E^{\mathcal{C}}}{\partial r^{(i,j)} \partial r^{(m,n)}}\f$ to the simulator.


*/

LocalWords:  CDDL yyyy Ellad Tadmor kim api atomistic interatomic ction pimpl
LocalWords:  discoverable const DataType LanguageName SpeciesName LengthUnit
LocalWords:  EnergyUnit ChargeUnit TemperatureUnit TimeUnit ArgumentName ref
LocalWords:  CallbackName SupportStatus Versioning infl Ni Cu virial monte Li
LocalWords:  carlo mathcal mathbf equiv ac cp ncp emptyset le unaccented cdots
LocalWords:  otimes bmatrix vdots ddots hessian html jpg pdf np ModelCreate sc
LocalWords:  ModelDriverCreate ModelCompute ModelRefresh ModelDestroy ProcessD
LocalWords:  requiredByAPI notSupported numberOfParticles particleSpeciesCodes
LocalWords:  particleContributing leftrightarrow partialEnergy partialForces
LocalWords:  partialParticleEnergy partialVirial partialParticleVirial EDr
LocalWords:  partialHessian GetNeighborList ProcessDEDrTerm
