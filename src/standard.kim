#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the Common Development
# and Distribution License Version 1.0 (the "License").
#
# You can obtain a copy of the license at
# http://www.opensource.org/licenses/CDDL-1.0.  See the License for the
# specific language governing permissions and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each file and
# include the License file in a prominent location with the name LICENSE.CDDL.
# If applicable, add the following below this CDDL HEADER, with the fields
# enclosed by brackets "[]" replaced with your own identifying information:
#
# Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.
#
# CDDL HEADER END
#

#
# Copyright (c) 2013--2015, Regents of the University of Minnesota.
# All rights reserved.
#
# Contributors:
#    Ryan S. Elliott
#    Ellad B. Tadmor
#    Valeriu Smirichinski
#


################################################################################
#
# KIM API Standard Definitions
#
# Release: This file is part of the kim-api.git repository.
#
################################################################################
#
# This file defines the KIM API standard argument names and their properties,
# the Neighbor Boundary Condition (NBC) methods supported by the KIM API, the
# list of standard particle species known to KIM, and a set of conventions
# defined by KIM that help to ensure that Models and Simulators are able to
# successfully communicate with each other.
#
# The requirements and capabilities of KIM Models and Simulators are defined in
# an accompanying plain text document referred to as a "KIM descriptor file".
#
# There are a number of line types that can occur in a KIM descriptor file:
#
#   1) Blank lines
#         These are lines containing only white-space characters.  These lines
#         are silently ignored by the KIM API.
#
#   2) Comment lines
#         These lines have a `#' as their first (non-white-space) character.
#         All other line types may end with a comment.  The beginning of such a
#         comment is indicated by the first occurrence of the `#' character.
#
#   3) Units handling line:
#         For Models, a variable `Unit_Handling' specifies whether the Model
#         can adjust its input and output to match a Simulator (`flexible') or
#         can only work with one set of units (`fixed').  This information is
#         ignored for Simulators.  At most one such line may occur in a KIM
#         descriptor file and it should be the second line in the descriptor
#         file which is not a comment or a blank line.  The line's first
#         non-white-space characters must be `Unit_Handling', followed by an
#         assignment symbol `:=' (white-space surrounding the assignment symbol
#         is ignored), followed by either `fixed' or `flexible'.
#
#         Example:
#         Unit_Handling := fixed
#
#   4) Base unit lines:
#         Five lines that describe a set of five base units from which all
#         other units are derived in a consistent way:
#
#         Unit_length      := `A' | `Bohr' | `cm' | `m' | `nm'
#         Unit_energy      := `amu*A^2/(ps)^2' | `erg' | `eV' | `Hartree' |
#                             `J' |`kcal/mol' | kJ/mol'
#         Unit_charge      := `C' | `e' | `statC'
#         Unit_temperature := `K'
#         Unit_time        := `fs' | `ps' | `ns' | `s'
#
#         The list of recognized units above may be extended in the future.
#         (The current list is based on the units used in 8 popular ab initio,
#         MC, MD and lattice dynamics codes: AMBER, CHARMM, DL_POLY, GROMACS,
#         LAMMPS, TOWHEE, VASP.)  As noted above all other units will be
#         derived from these units in a consistent manner.
#
#         Example:
#         Unit_length      := A
#         Unit_energy      := eV
#         Unit_charge      := e
#         Unit_temperature := K
#         Unit_time        := ps
#
#   5) Section lines
#         These lines identify logically distinct sections within the KIM
#         descriptor file.  All lines following a Section line, up to the next
#         Section line or end of the file, will be assigned to the indicated
#         section.  Currently, there are five sections defined by the KIM
#         standard:
#
#            * PARTICLE_SPECIES
#            * CONVENTIONS
#            * MODEL_INPUT
#            * MODEL_OUTPUT
#            * MODEL_PARAMETERS
#
#         These sections may occur in any order within a KIM descriptor file,
#         however the order given above is recommended.  A section line may
#         only occur once within a KIM descriptor file.
#
#   6) Data lines
#         These lines are used to specify the information that a Model
#         (Simulator) will provide to and require from a Simulator (Model), as
#         well as the conventions that the Model (Simulator) uses.  There are
#         currently three types of Data lines:
#
#            * Species Data lines
#               This line type defines the particle species supported by the
#               Simulator/Model and should only be used within the
#               PARTICLE_SPECIES section of the KIM descriptor file.  The line
#               consists of three white-space separated (case sensitive)
#               strings of maximum KIM_KEY_STRING_LENGTH length.  The three
#               strings, in order, are as follows:
#
#                  1) Name: This string gives a unique name to the
#                           particle species.  This name is checked against
#                           the standard list in `standard.kim' (below).
#
#                  2) Type: This must be `spec'.
$
#                  3) code: This is the non-negative integer that the Model
#                           uses internally to identify the particle species.
#                           The special value of `-1' indicates that the Model
#                           will set the code value during the execution of its
#                           `model_init' function.  The value specified by a
#                           Simulator is ignored.
#
#            * Flag Data lines
#               This line type defines a convention (or flag), that can be used
#               to ensure that Models and Simulators are able to work together,
#               and should only be used within the CONVENTIONS section of the
#               KIM descriptor file.  The line consists of two white-space
#               separated (case sensitive) strings of maximum
#               KIM_KEY_STRING_LENGTH length.  The two strings, in order, are
#               as follows:
#
#                  1) Name: This string gives a unique name to the convention.
#                           This name is checked against the standard list in
#                           `standard.kim' (below).
#
#                  2) Type: This must be `flag'.
#
#            * Argument Data lines
#               This line type defines a quantity that is associated with one
#               or more values that must be shared between the Model and
#               Simulator and should only be used within the MODEL_INPUT,
#               MODEL_OUTPUT, and MODEL_PARAMETERS sections of the KIM
#               descriptor file.  These are analogous the the arguments of a
#               function call.  The line consists of five white-space separated
#               (case sensitive) strings of maximum KIM_KEY_STRING_LENGTH
#               length.  The values of these strings are checked against the
#               standard list in `standard.kim' (below) for lines contained in
#               the MODEL_INPUT and MODEL_OUTPUT sections of the KIM descriptor
#               file (but not for lines in the MODEL_PARAMETERS section).  The
#               five strings, in order, are as follows:
#
#                  1) Name: This string gives a unique name to the argument.
#
#                  2) Type: This string defines the data-type of the associated
#                           values.  Currently there are six types:
#
#                           KIM string     C/C++ type      Fortran type
#
#                           `integer'      int             integer(c_int)
#                           `float'        float           real(c_float)
#                           `double'       double          real(c_double)
#                           `method'       void (*)()      c_funptr
#                           `pointer'      void *          c_ptr
#
#                           The first three are self-explanatory.  (Note:
#                           programmers should use the types listed above, as
#                           this will best ensure that cross language compiled
#                           code created one a single machine using a single
#                           compiler suite will work correctly together.  In
#                           particular, Fortran programmers should not use more
#                           specific types such as `integer*4' or `real*8' as
#                           these could lead to compatibility problems on some
#                           machines.)  The `method' type allows the Model
#                           (Simulator) to provide pointers to
#                           functions/subroutines that the Simulator (Model)
#                           may use to perform certain tasks at runtime.  The
#                           `pointer' type is capable of pointing to an
#                           arbitrary location in memory and is a catch-all
#                           type that can be used when none of the other types
#                           are appropriate.
#
#                  3) Unit: This string defines the physical units of the
#                           values (which must all be the same for all
#                           components of array quantities).
#                           Possible values are:
#
#                              * none
#                              * mass
#                              * length
#                              * time
#                              * energy
#                              * velocity
#                              * force
#                              * torque
#                              * temperature
#                              * pressure
#                              * stress
#                              * dynamic_viscosity
#                              * charge
#                              * dipole
#                              * electric_field
#                              * density
#
#                  4) Shape: This string defines the rank (number of array
#                            dimensions) and extent (size of each dimension)
#                            for the values associated with the argument
#                            quantity.
#
#                            The format of the string is a `[' followed by an
#                            (optional) comma separated list of integers or
#                            character strings, followed by a `]'.
#
#                            If an integer is provided it sets the extent of
#                            the corresponding dimension.  Otherwise one of the
#                            three following strings may be used:
#
#                            `numberOfParticles', `numberOfSpecies', `:'
#
#                            If either of the first two options is present, the
#                            KIM_API_allocate() function will substitute the
#                            value of its `nParticles' or its `nSpecies'
#                            arguments, respectively.  If, after this
#                            substitution the extents of EACH dimension is
#                            known, then the KIM_API_allocate() function will
#                            allocate the memory for this argument (otherwise,
#                            if any strings are equal to `:', then memory for
#                            this argument will not be allocated by the
#                            KIM_API_allocate() function and must be allocated
#                            by the Simulator and registered in the KIM API
#                            object using the KIM_API_set_data() or
#                            KIM_API_setm_data() functions).
#
#                            White-space is not allowed between the `[' and `]'
#                            characters.
#
#                            NOTE that multi-dimensional arrays are defined as
#                            in C with the `fast-index' corresponding to the
#                            last in the list.  No conversion is necessary to
#                            use such an array in Fortran.  The Fortran
#                            programmer simply needs to define the dimensions
#                            of the array in the reverse order.  For example, a
#                            KIM Shape string [10,3] corresponds to a C array
#                            of shape [10][3] and to a Fortran array of shape
#                            (3,10).
#
#                            Providing a few examples is the best way to
#                            clearly define the meaning of the Shape string:
#
#                            * []   - This defines a scalar value (rank=0)
#
#                            * [10] - This defines a vector (rank=1) of 10
#                                     values
#
#                            * [numberOfParticles] - This defines a vector (rank=1)
#                                     of `numberOfParticles' values.  If the
#                                     KIM_API_allocate function is called as
#
#                       KIM_API_allocate(pkim, nParticles, nSpeciess, kimerr)
#
#                                     it will allocate memory for this
#                                     argument using the value of `nParticles'.
#
#                            * [numberOfSpecies] - This defines a vector
#                                     (rank=1) of `numberOfSpecies'
#                                     values.  If the KIM_API_allocate function
#                                     is called as
#
#                       KIM_API_allocate(pkim, nParticles, nSpeciess, kimerr)
#
#                                    it will allocated memory for this argument
#                                    using the value of `nSpecies'.
#
#                            * [12,10,5] - This defines a three-dimensional
#                                    array (rank=3) of size 12 by 10 by 5.
#                                    Memory for this array can be allocated by
#                                    the KIM_API_allocate() function.
#
#                            * [numberOfParticles,12,15] - This defines a three-
#                                    dimensional array (rank=3) of size
#                                    `numberOfParticles' by 12 by 15.  Memory for
#                                    this array can be allocated by the
#                                    KIM_API_allocate() function.
#
#                            * [:,12] - This defines a two-dimensional array
#                                    (rank=2) of size (an unspecified length)
#                                    by 12.  In this case, KIM_API_allocate()
#                                    will not allocate any memory for this
#                                    argument.  When the only unknown dimension
#                                    range is the (slowest) first dimension,
#                                    the Simulator must allocate (and
#                                    eventually free) memory for this argument
#                                    and use the KIM_API_set_data() function in
#                                    order to register the memory location of
#                                    the values for this argument.  When this
#                                    is done the KIM_API_set_data() function
#                                    will determine (and set) the EXTENT of the
#                                    first dimension using the known EXTENTs of
#                                    the remaining dimensions and the `size'
#                                    argument.  If the range of one or more
#                                    dimensions other than the first is
#                                    unknown, then the KIM_API_set_data()
#                                    function does not try to determine the
#                                    unknown EXTENT(s) and will exit with an
#                                    error.  In this type of situation the
#                                    KIM_API_set_shape() function (see below)
#                                    must be used before KIM_API_set_data() is
#                                    called.
#
#                                    NOTE: recall that for standard arguments
#                                    the shape strings are compared with the
#                                    corresponding values in standard.kim (this
#                                    file).  Thus, specifying a constant
#                                    EXTENT, such as the `12' in this example,
#                                    has meaning for the Simulator/Model
#                                    matching process.  Further, these values
#                                    are stored in the KIM API object (zero is
#                                    substituted wherever a `:' occurs) and can
#                                    be retrieved at run-time (before they are
#                                    overwritten by a call to
#                                    KIM_API_set_shape()).
#
#
#                            * [12,numberOfParticles] - This defines a two-
#                                    dimensional array (rank=2) of size 12 by
#                                    `numberOfParticles'.  Memory for this array
#                                    can be allocated by the KIM_API_allocate()
#                                    function.
#
#                            * [:,:,:,12,:,numberOfSpecies] - This defines
#                                   a six-dimensional array (rank=6).  Memory
#                                   for this array cannot be allocated by the
#                                   KIM_API_allocate() function.  The Simulator
#                                   must use the KIM_API_set_shape() function
#                                   to register the range of all dimensions
#                                   (i.e, specify the explicit values for the
#                                   shape).  Then, the Simulator must allocate
#                                   (and eventually free) memory for this
#                                   argument and use the KIM_API_set_data()
#                                   function in order to register the memory
#                                   location of the values for this argument.
#
#
#
#                  5) Requirements: This string may be empty or `optional'.  An
#                                   empty string indicates that the argument is
#                                   required to be present by the
#                                   Simulator/Model (i.e., the Simulator/Model
#                                   will read from and/or write to the values
#                                   associated with this argument).  Models may
#                                   use the `optional' string.  If this is
#                                   specified for an input argument, it means
#                                   that the Model can run without receiving
#                                   this argument (but it may use it if
#                                   provided).  If specified for an output
#                                   argument, it means that the argument will
#                                   only be computed if required by the
#                                   Simulator.
#
################################################################################
#
# KIM_API_Version line:
#
# This line lists the (oldest) KIM API version for which the Model or Simulator
# is known to be compatible.  The format is <MAJOR>.<MINOR>[.<PATCH>].  Some
# examples are:
#
#    KIM_API_Version := 1.6
#    KIM_API_Version := 1.6.4
#
# The <PATCH> value, if provided, is ignored.  All ".kim" files must have a
# KIM_API_Version line; except for this file (standard.kim) which should not
# have a KIM_API_Version line.
#
################################################################################

################################################################################
#
# Each Model KIM descriptor file must have a Unit_Handling line.
# There are two options:
#
#    Unit_Handling := fixed      The Model can work only with the units
#                                specified in its descriptor file
#
#    Unit_Handling := flexible   The Model can change the units it
#                                works with when requested
#
# Simulator KIM descriptor files and this file (standard.kim) should not have a
# Unit_Handling line.
#
################################################################################

################################################################################
#
# Base unit lines:
# Five lines that describe a set of five base units from which all other units
# are derived in a consistent way.  See above for valid values.
#
# All KIM descriptors must have these five lines.  In this file (standard.kim),
# these lines serve to define the "KIM Standard base units".  These values are
# recommended for use as the defaults for all Simulators and Models.  However,
# these values are not used as part of the Simulator/Model matching process.
#
################################################################################

Unit_length      := A
Unit_energy      := eV
Unit_charge      := e
Unit_temperature := K
Unit_time        := ps

################################################################################
#
# The PARTICLE_SPECIES section
#
################################################################################

PARTICLE_SPECIES:

################################################################################
#
# The list of standard KIM particle species
#
# The code listed in 'standard.kim' is, where appropriate, the atomic number.
# However, this value is ignored and only the code value provided by the Model
# is retained.
#
# In order for a Simulator and Model to match, a Model must be able to support
# all particle species required by the Simulator as indicated in its descriptor
# file.  If no lines appear in the PARTICLE_SPECIES section for both the
# Simulator and the Model, then a Simulator/Model match is possible.  This
# option allows for Models and Simulators that do not assign any specific
# physical type to their (single) particle species.
#
# Symbol/name               Type         code
#
################################################################################
H                           spec         1              # Hydrogen
He                          spec         2              # Helium
Li                          spec         3              # Lithium
Be                          spec         4              # Beryllium
B                           spec         5              # Boron
C                           spec         6              # Carbon
N                           spec         7              # Nitrogen
O                           spec         8              # Oxygen
F                           spec         9              # Fluorine
Ne                          spec         10             # Neon
Na                          spec         11             # Sodium
Mg                          spec         12             # Magnesium
Al                          spec         13             # Aluminum
Si                          spec         14             # Silicon
P                           spec         15             # Phosphorus
S                           spec         16             # Sulfur
Cl                          spec         17             # Chlorine
Ar                          spec         18             # Argon
K                           spec         19             # Potassium
Ca                          spec         20             # Calcium
Sc                          spec         21             # Scandium
Ti                          spec         22             # Titanium
V                           spec         23             # Vanadium
Cr                          spec         24             # Chromium
Mn                          spec         25             # Manganese
Fe                          spec         26             # Iron
Co                          spec         27             # Cobalt
Ni                          spec         28             # Nickel
Cu                          spec         29             # Copper
Zn                          spec         30             # Zinc
Ga                          spec         31             # Gallium
Ge                          spec         32             # Germanium
As                          spec         33             # Arsenic
Se                          spec         34             # Selenium
Br                          spec         35             # Bromine
Kr                          spec         36             # Krypton
Rb                          spec         37             # Rubidium
Sr                          spec         38             # Strontium
Y                           spec         39             # Yttrium
Zr                          spec         40             # Zirconium
Nb                          spec         41             # Niobium
Mo                          spec         42             # Molybdenum
Tc                          spec         43             # Technetium
Ru                          spec         44             # Ruthenium
Rh                          spec         45             # Rhodium
Pd                          spec         46             # Palladium
Ag                          spec         47             # Silver
Cd                          spec         48             # Cadmium
In                          spec         49             # Indium
Sn                          spec         50             # Tin
Sb                          spec         51             # Antimony
Te                          spec         52             # Tellurium
I                           spec         53             # Iodine
Xe                          spec         54             # Xenon
Cs                          spec         55             # Cesium
Ba                          spec         56             # Barium
La                          spec         57             # Lanthanum
Ce                          spec         58             # Cerium
Pr                          spec         59             # Praseodymium
Nd                          spec         60             # Neodymium
Pm                          spec         61             # Promethium
Sm                          spec         62             # Samarium
Eu                          spec         63             # Europium
Gd                          spec         64             # Gadolinium
Tb                          spec         65             # Terbium
Dy                          spec         66             # Dysprosium
Ho                          spec         67             # Holmium
Er                          spec         68             # Erbium
Tm                          spec         69             # Thulium
Yb                          spec         70             # Ytterbium
Lu                          spec         71             # Lutetium
Hf                          spec         72             # Hafnium
Ta                          spec         73             # Tantalum
W                           spec         74             # Tungsten
Re                          spec         75             # Rhenium
Os                          spec         76             # Osmium
Ir                          spec         77             # Iridium
Pt                          spec         78             # Platinum
Au                          spec         79             # Gold
Hg                          spec         80             # Mercury
Tl                          spec         81             # Thallium
Pb                          spec         82             # Lead
Bi                          spec         83             # Bismuth
Po                          spec         84             # Polonium
At                          spec         85             # Astatine
Rn                          spec         86             # Radon
Fr                          spec         87             # Francium
Ra                          spec         88             # Radium
Ac                          spec         89             # Actinium
Th                          spec         90             # Thorium
Pa                          spec         91             # Protactinium
U                           spec         92             # Uranium
Np                          spec         93             # Neptunium
Pu                          spec         94             # Plutonium
Am                          spec         95             # Americium
Cm                          spec         96             # Curium
Bk                          spec         97             # Berkelium
Cf                          spec         98             # Californium
Es                          spec         99             # Einsteinium
Fm                          spec         100            # Fermium
Md                          spec         101            # Mendelevium
No                          spec         102            # Nobelium
Lr                          spec         103            # Lawrencium
Rf                          spec         104            # Rutherfordium
Db                          spec         105            # Dubnium
Sg                          spec         106            # Seaborgium
Bh                          spec         107            # Bohrium
Hs                          spec         108            # Hassium
Mt                          spec         109            # Meitnerium
Ds                          spec         110            # Darmstadtium
Rg                          spec         111            # Roentgenium
Cn                          spec         112            # Copernicium
Uut                         spec         113            # Ununtrium
Uuq                         spec         114            # Ununquadium
Uup                         spec         115            # Ununpentium
Uuh                         spec         116            # Ununhexium
Uus                         spec         117            # Ununseptium
Uuo                         spec         118            # Ununoctium
electron                    spec         200            # electrons
user01                      spec         201            # user defined
user02                      spec         202            # user defined
user03                      spec         203            # user defined
user04                      spec         204            # user defined
user05                      spec         205            # user defined
user06                      spec         206            # user defined
user07                      spec         207            # user defined
user08                      spec         208            # user defined
user09                      spec         209            # user defined
user10                      spec         210            # user defined
user11                      spec         211            # user defined
user12                      spec         212            # user defined
user13                      spec         213            # user defined
user14                      spec         214            # user defined
user15                      spec         215            # user defined
user16                      spec         216            # user defined
user17                      spec         217            # user defined
user18                      spec         218            # user defined
user19                      spec         219            # user defined
user20                      spec         220            # user defined

################################################################################
#
# The CONVENTIONS section
#
# This section includes information on general operation conventions of a
# Simulator/Model
#
# Each line in the CONVENTIONS section consists of a `Name' and `Type'.
#
################################################################################

CONVENTIONS:

################################################################################
#
# In an actual KIM descriptor (.kim) file, exactly ONE of the following two
# lines must be included.  This information is used by neighbor lists and the
# process_d?Edr? mechanism.
#
################################################################################
ZeroBasedLists              flag        # Presence of this line indicates that
                                        # indexes for particles are from 0 to
                                        # numberOfParticles-1 (C-style)

OneBasedLists               flag        # Presence of this line indicates that
                                        # indexes for particles are from 1 to
                                        # numberOfParticles (Fortran-style)

################################################################################
#
# The following three lines are related to the locator/iterator neighbor list
# access mode.  These ensure that a Model will not try to use an access mode
# that is not supported by the routines provided by the Simulator.
#
# If Neigh_IterAccess and Neigh_LocaAccess are both in the file, it means that
# the Model/Simulator can work with either mode but does not require both.
#
# If Neigh_BothAccess is in the file, it means that the Model (Simulator)
# requires (provides) both access modes in order to function.
#
# It is an error to include Neigh_BothAccess with either of the other two
# options in a KIM descriptor (.kim) file.
#
################################################################################
Neigh_IterAccess            flag        # works with iterator mode

Neigh_LocaAccess            flag        # works with locator mode

Neigh_BothAccess            flag        # need both locator and iterator modes


################################################################################
#
# Neighbor list and Boundary Condition (NBC) methods
#
# These are the KIM standard methods for dealing with neighbor lists and
# boundary conditions.
#
# For each listed particle, i, in the configuration a:
#   `full neighbor list' provides a list of every particle, j, that is a
#                        neighbor of particle i;
#   `half neighbor list' provides a list of every particle, j >= i, that is a
#                        neighbor of particle i.
#
# Neighbor lists provided by a Simulator must contain all particles in the
# configuration within the Model's cutoff radius.  However, it is typical that
# Simulators will include, for efficiency reasons, additional particles that
# are outside the cutoff (the so-called "skin").  The Model is responsible for
# determining which particles in the neighbor list are inside its cutoff
# distance.
#
################################################################################

# In the CLUSTER method, the Model receives the number of particles and
# coordinates without additional information (such as neighbor lists or other
# boundary condition specifiers) and computes requested quantities under the
# assumption that the particles form an isolated cluster.  For example, if
# energy and forces are requested, it will compute the total energy of all the
# particles based on the supplied particle coordinates and the derivative of
# the total energy with respect to the positions of the particles.
#
CLUSTER                     flag        # The Model needs only coordinates to
                                        # compute; a neighbor list is not used.

# In the NEIGH_PURE methods (NEIGH_PURE_H and NEIGH_PURE_F), the Model receives
# the number of particles, coordinates and a full or half neighbor list. The
# neighbor list defines the environment of each particle, from which the
# particles's energy is defined.  In the case of a half list, the value of the
# argument `numberContributingParticles' indicates that the first
# `numberContributingParticles' contribute their energy to the total and the
# remaining particles do not contribute to the energy (they are "padding"
# particles).  When `numberContributingParticles' is equal to `numberParticles'
# the half list is called "symmetric", otherwise it is called "unsymmetric."
# In the case of a full list, any particle that has one or more neighbors
# contributes its energy to the total and those particles with zero neighbors
# do not contribute to the total energy.  The model computes the requested
# quantities using the supplied information.  For example, if energy and forces
# are requested, it will compute the total energy of all the particles based on
# their neighbor lists and the derivative of the total energy with respect to
# the positions of the particles.  This method can be used with codes that use
# padding particles to apply boundary conditions.  The padding particles are
# treated as regular particles by the Model, and it is up to the calling code
# to discard some information such as the forces on the padding particles and to
# compute the appropriate total energy from per-particle energies of the
# physical particles, or to use a modified neighbor list to obtain the desired
# values.
#
NEIGH_PURE_H                flag        # This is the Pure Half neighbor list
                                        # method.  The model needs
                                        # `coordinates', a half neighbor list
                                        # (with data stored in the
                                        # `neighObject' argument), the
                                        # `numberContributingParticles', and
                                        # the `get_neigh' method supplied by
                                        # the Simulator.

NEIGH_PURE_F                flag        # This is the Pure Full neighbor list
                                        # method.  The model needs
                                        # `coordinates', a full neighbor list
                                        # (with data stored in the
                                        # `neighObject' argument), and the
                                        # `get_neigh' method supplied by the
                                        # Simulator.


# In the NEIGH_RVEC methods (NEIGH_RVEC_H and NEIGH_RVEC_F), the Model receives
# the number of particles, coordinates, a half or full neighbor list, and the
# relative position vectors r_ij (r_ij = x_j-x_i). The neighbor list and r_ij
# vectors define the environment of each particle, from which the particles's
# energy is defined.  In the case of a half list, a neighbor pair i and j
# (where i < j) with relative position vector (RVEC) r_ij defines two pieces of
# information: (1) j is a neighbor of i with RVEC r_ij and (2) i is a neighbor
# of j with RVEC r_ji = -r_ij.  Additionally, the value of the argument
# `numberContributingParticles' indicates that the first
# `numberContributingParticles' contribute their energy to the total and the
# remaining particles do not contribute to the energy (they are "padding"
# particles).  When `numberContributingParticles' is equal to `numberParticles'
# the half list is called "symmetric", otherwise it is called "unsymmetric."
# In the case of a full list, any particle that has one or more neighbors
# contributes its energy to the total and those particles with zero neighbors
# do not contribute to the total energy.  The Model computes the requested
# quantities using the supplied information.  For example, if energy and forces
# are requested, it will compute the total energy of all the particles based on
# their neighbor lists and the derivative of the total energy with respect to
# the positions of the particles.  These methods enable the application of
# general periodic boundary conditions, including multiple images.  A possible
# future extension to these methods is to allow the Simulator to provide a
# ForceTransformation() function for each neighbor, which would enable the
# application of complex boundary conditions such as torsion and objective
# boundary conditions.
#
NEIGH_RVEC_H                flag        # This is the Relative Vector Boundary
                                        # Condition Half neighbor list method.
                                        # The Model needs `coordinates', a half
                                        # neighbor list (with data stored in
                                        # the `neighObject' argument),
                                        # `numberContributingParticles', and
                                        # the `get_neigh' method supplied by
                                        # the Simulator.  The `neighObject'
                                        # argument must also contain the
                                        # relative position vectors (RVEC)
                                        # (which are returned by the
                                        # `get_neigh' function).

NEIGH_RVEC_F                flag        # This is the Relative Vector Boundary
                                        # Condition Full neighbor list method.
                                        # The Model needs `coordinates', a full
                                        # neighbor list (with data stored in
                                        # the `neighObject' argument), and the
                                        # `get_neigh' method supplied by the
                                        # Simulator.  The `neighObject'
                                        # argument must also contain the
                                        # relative position vectors (RVEC)
                                        # (which are returned by the
                                        # `get_neigh' function).

# In the MI_OPBC methods (MI_OPBC_H and MI_OPBC_F), the Model receives the
# number of particles and coordinates, the side lengths for the periodic
# orthogonal box and a neighbor list.  It assumes all particles lie inside the
# periodic box.  Side lengths of the box must be at least twice the cutoff
# range.  This method computes the requested quantities under the assumption
# that the particles are subjected to the minimum image, orthogonal, periodic
# boundary conditions.
#
MI_OPBC_H                   flag        # This is the Minimum Image Orthogonal
                                        # Periodic Boundary Condition Half
                                        # neighbor list method.  The Model
                                        # needs `coordinates', a half neighbor
                                        # list (with data stored in the
                                        # `neighObject' argument),
                                        # `numberContributingParticles', the
                                        # `get_neigh' method supplied by the
                                        # Simulator, and the `boxSideLengths'
                                        # argument (which specifies the three
                                        # side-lengths of the orthogonal
                                        # simulation box).

MI_OPBC_F                   flag        # This is the Minimum Image Orthogonal
                                        # Periodic Boundary Condition Full
                                        # neighbor list method.  The Model
                                        # needs `coordinates', a full neighbor
                                        # list (with data stored in the
                                        # `neighObject' argument), the
                                        # `get_neigh' method supplied by the
                                        # Simulator, and the `boxSideLengths'
                                        # argument (which specifies the three
                                        # side-lengths of the orthogonal
                                        # simulation box).


################################################################################
#
# The MODEL_INPUT section
#
################################################################################

MODEL_INPUT:

################################################################################
#
# Every data line in the input section of a KIM descriptor file of a Simulator
# and Model consists of five fields:
#
# Name
# Type
# Unit
# Shape
# Requirements
#
# Each of these lines must exactly match with one of the standard definitions
# given below except for the field `Requirements'.  The `Requirements' field is
# only meaningful in a Model KIM descriptor file as described above.  It is
# therefore left blank in the standard definitions below.
#
################################################################################

################################################################################
#
# numberOfParticles : The number of particles in the configuration passed
#                     between the Model and Simulator.
#
# Particles are always numbered sequentially starting from 0 or 1 depending on
# the ZeroBasedLists/OneBasedLists convention setting.  This argument is
# required for all Models and Simulators.  A Simulator must allocate memory for
# this argument and register it in the KIM API object (via KIM_API_allocate()
# or KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit                Shape
#
numberOfParticles           integer      none                []

################################################################################
#
# numberContributingParticles: The number of particles that contribute to the
#                              energy (required for all half neighbor lists).
#
# This argument allows a half neighbor list to be "unsymmetric."  Only the
# first `numberContributingParticles' particles will contribute their energy to
# the total.  If supported, a Simulator must allocate memory for this argument
# and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
numberContributingParticles integer      none               []

################################################################################
#
# numberOfSpecies: The number of species of particles contained in the
#                  configuration passed between the Model and Simulator.
#
# This argument is required for any Model/Simulator that specifies one or more
# particle species in the PARTICLE_SPECIES section.  If supported, a Simulator
# must allocate memory for this argument and register it in the KIM API object
# (via KIM_API_allocate() or KIM_API_set_data()) before the
# KIM_API_model_compute() function is called.  The Simulator is free to change
# this pointer at any time.
#
# Name                      Type         Unit              Shape
#
numberOfSpecies             integer      none              []

################################################################################
#
# particleSpecies : A vector of integers indicating the species of each
#                   particle in the configuration passed between the Model and
#                   Simulator.
#
# The values in this vector must correspond to the `code' specified in the
# Model's KIM descriptor file.  This argument is required for any
# Model/Simulator that specifies one or more particle species in the
# PARTICLE_SPECIES section.  If supported, a Simulator must allocate memory for
# this argument and register it in the KIM API object (via KIM_API_allocate()
# or KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleSpecies             integer      none               [numberOfParticles]

################################################################################
#
# coordinates : An array of floating-point numbers specifying the spatial
#               location of each of the numberOfParticles particles in the
#               configuration passed between the Model and Simulator.
#
# This argument is required for all Models and Simulators.  A Simulator must
# allocate memory for this argument and register it in the KIM API object (via
# KIM_API_allocate() or KIM_API_set_data()) before the KIM_API_model_compute()
# function is called.  The Simulator is free to change this pointer at any
# time.
#
# Name                      Type         Unit               Shape
#
coordinates                 double       length             [numberOfParticles,3]

################################################################################
#
# particleCharge : An array of floating-point numbers specifying the charge of
#                  each particle.
#
# If supported, a Simulator must allocate memory for this argument and register
# it in the KIM API object (via KIM_API_allocate() or KIM_API_set_data())
# before the KIM_API_model_compute() function is called.  The Simulator is free
# to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleCharge              double       charge             [numberOfParticles]

################################################################################
#
# particleSize : An array of floating-point numbers specifying the size of each
#                particle.
#
# If supported, a Simulator must allocate memory for this argument and register
# it in the KIM API object (via KIM_API_allocate() or KIM_API_set_data())
# before the KIM_API_model_compute() function is called.  The Simulator is free
# to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleSize                double       length             [numberOfParticles]

################################################################################
#
# get_neigh : A pointer to the neighbor list access function that is provided
#             by the Simulator.
#
# This argument is required for Models/Simulators that support any NBCs other
# than CLUSTER. It is recommended that for Models this argument be optional to
# ensure that a Model is compatible with the widest possible set of Simulators.
#
# If supported, a Simulator must allocate memory for this argument and register
# it in the KIM API object (via KIM_API_allocate() or KIM_API_set_data())
# before the KIM_API_model_compute() function is called.  The Simulator is free
# to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
get_neigh                   method       none               []

################################################################################
#
# process_dEdr : A pointer to a function that can compute arbitrary linear
#                combinations of the first derivative of the Model's energy
#                with respect to the distances between particles.
#
# During the Model's compute loop, this function will be called multiple times
# with a scalar value representing a contribution to the derivative of the
# energy with respect to a pair distance.  The Simulator can use this
# information to compute, via the chain-rule, many properties.  Examples
# include forces, the virial and other thermodynamic tensions.  If supported, a
# Simulator must allocate memory for this argument and register it in the KIM
# API object (via KIM_API_allocate() or KIM_API_set_data()) before the
# KIM_API_model_compute() function is called.  The Simulator is free to change
# this pointer at any time.
#
# Name                      Type         Unit               Shape
#
process_dEdr                method       none               []

################################################################################
#
# process_d2Edr2 : A pointer to a function that can compute arbitrary linear
#                  combinations of the second derivative of the Model's energy
#                  with respect to the distances between particles.
#
# The function will be called multiple times with a scalar value representing a
# contribution to the second derivative of the energy with respect to two pair
# distances.  The Simulator can use this information (often in conjunction with
# process_dEdr) to compute, via the chain-rule, many properties.  An example is
# the hessian.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
process_d2Edr2              method       none               []

################################################################################
#
# neighObject : A pointer to the data for the neighbor list that is provided by
#               the Simulator.
#
# This argument is required for Models/Simulators that support any NBC other
# than CLUSTER.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
neighObject                 pointer      none               []

################################################################################
#
# boxSideLengths : A vector of three floating-point numbers indicating the side
#                  lengths of the minimum-image periodic orthogonal box.
#
# This argument is required for Models/Simulators that support the following
# NBCs: MI_OPBC_H and MI_OPBC_F.  If supported, a Simulator must allocate
# memory for this argument and register it in the KIM API object (via
# KIM_API_allocate() or KIM_API_set_data()) before the KIM_API_model_compute()
# function is called.  The Simulator is free to change this pointer at any
# time.
#
# Name                      Type         Unit               Shape
#
boxSideLengths              double       length             [3]

################################################################################
#
# temperature : A scalar specifying the system temperature.
#
# This argument is required for a special class of temperature-dependent models.
#
# Name                      Type         Unit               Shape
#
temperature                 double       temperature        []


################################################################################
#
# The MODEL_OUTPUT section
#
################################################################################

MODEL_OUTPUT:

################################################################################
#
# The data lines in the output section of the KIM descriptor file of a
# Simulator and Model consist of five fields and must satisfy the same
# restrictions as the lines in the input section as explained above (following
# the MODEL_INPUT section line).
#
################################################################################

################################################################################
#
# compute : A pointer to the Model's compute function which given the input
#           defined in the MODEL_INPUT section will calculate quantities
#           described in the MODEL_OUTPUT section.
#
# This argument is required for all Models and Simulators.  A Model must
# register a pointer to its `compute' function during the execution of
# KIM_API_model_init().  The Model is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
compute                     method       none               []

################################################################################
#
# reinit : A pointer to the Model's reinit function (called to reinitialize a
#          Model following a change to its parameters by a Simulator).
#
# This argument is required if a Models publishes its parameters.  However, the
# argument should be included, as optional, by all Models to ensure maximum
# compatibility with Simulators (who should only include the argument if they
# use it).  If supported, a Model must register a pointer to its `reinit'
# function during the execution of KIM_API_model_init().  The Model is free to
# change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
reinit                      method       none               []

################################################################################
#
# destroy : A pointer to the Model's destroy function (called by a Simulator
#           prior to a KIM_API_free() call to allow the Model to perform any
#           necessary clean-up operations).
#
# This argument is required if a Model publishes its parameters (so that it can
# free the memory that it allocated for its parameters in its init function).
# However, the argument should be included by all Models (as optional, at
# least) to ensure maximum compatibility with Simulators (who should only
# include the argument if they use it).  If supported, a Model must register a
# pointer to its `destroy' function during the execution of
# KIM_API_model_init().  The Model is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
destroy                     method       none               []

################################################################################
#
# cutoff : A floating-point number indicating the Model's range of interactions
#          (i.e. its cutoff radius).
#
# This argument is required for all Models/Simulators.  This value should not
# be modified by the Simulator.  A Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_init() function is called.  The
# Simulator is free to change this pointer at any time.  However, when such a
# change occurs, the Simulator must ensure that the value stored in the memory
# pointed to is preserved.  If the Model allows for its cutoff distance to be
# changed it will provide the parameter PARAM_FREE_cutoff (see below) which can
# be changed.  Once the PARAM_FREE_cutoff parameter has been changed and the
# Model's reinit function called, the Model must update the value of `cutoff'.
#
# Name                      Type         Unit               Shape
#
cutoff                      double       length             []

################################################################################
#
# energy : A floating-point number corresponding to the total energy of the
#          configuration of particles passed between the Model and Simulator.
#
# This argument should, ideally, be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
energy                      double       energy             []

################################################################################
#
# forces : An array of floating-point numbers corresponding to the total force
#          acting on each particle in the configuration of particles passed
#          between the Model and Simulator.  The force vector on a particle is
#          defined as the negative of the gradient of the energy with respect
#          to the particle's coordinate vector.
#
# This argument should be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
forces                      double       force              [numberOfParticles,3]

################################################################################
#
# particleEnergy : A vector of floating-point numbers corresponding to the
#                 energy of each particle in the configuration passed between
#                 the Model and Simulator.
#
# This argument should, ideally, be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleEnergy              double       energy             [numberOfParticles]

################################################################################
#
# virial : A symmetric second-order tensor corresponding to the total virial
#          for the configuration of particles passed between the Model and
#          Simulator.  The "stress" sign convention is used: tensile quantities
#          are positive and compressive quantities are negative. Thus, the
#          pressure is the negative of the spherical part of the Cauchy stress
#          which is given by one third the sum of the 11, 22 and 33 components
#          of the virial divided by a representative volume.
#
# The components of this 3 x 3 symmetric tensor are stored in a compact vector
# form with 6 components in accordance with the Voigt convention:
#
# {11,22,33,23,13,12} or {xx,yy,zz,yz,xz,xy}
#
# A Model may support the virial computation by having the KIM API compute it
# via the default process_dEdr mechanism.  (In this case the Model will list
# the `process_dEdr' argument in its descriptor file and call the
# KIM_API_process_dEdr() function in its compute loop.  The Simulator should
# list `virial' in its descriptor file.)
#
# This argument should, ideally, be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
virial                      double       energy             [6]

################################################################################
#
# particleVirial : A symmetric second-order tensor corresponding to the per
#                  particle virial for the configuration of particles passed
#                  between the Model and Simulator.  The "stress" sign
#                  convention is used: tensile quantities are positive and
#                  compressive quantities are negative.  Thus, the trace of the
#                  virial (sum of the 11, 22, and 33 components) is related to
#                  the pressure, however the sign convention is opposite that
#                  normally used for pressure.
#
# The components of each 3 x 3 symmetric tensor are stored in a compact vector
# form with 6 components in accordance with the Voigt convention:
#
# {11,22,33,23,13,12} or {xx,yy,zz,yz,xz,xy}
#
# A Model may support the virial computation by having the KIM API compute it
# via the default process_dEdr mechanism.  (In this case the Model will list
# the `process_dEdr' argument in its descriptor file and call the
# KIM_API_process_dEdr() function in its compute loop.  The Simulator should
# list `particleVirial' in its descriptor file.)
#
# This argument should, ideally, be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
particleVirial              double       energy             [numberOfParticles,6]

################################################################################
#
# hessian : A matrix of second derivatives of the Model's energy.  For
#           computational efficiency the matrix is stored as a
#           numberOfParticles by numberOfParticles array of 3 by 3 matrices.
#
# A Model may support the hessian computation by having the KIM API compute it
# via the default process_dEdr and process_dE2dr2 mechanisms.  (In this case
# the Model will list the `process_dEdr' and `process_dE2dr2' arguments in its
# descriptor file and call the KIM_API_process_dEdr() and
# KIM_API_process_d2Edr2() functions in its compute loop.  The Simulator should
# list `hessian' in its descriptor file.)  In the future a sparse array format
# may be introduces in order to reduce memory usage for this and other similar
# arguments.
#
# This argument should, ideally, be optional to ensure maximum Model/Simulator
# compatibility.  If supported, a Simulator must allocate memory for this
# argument and register it in the KIM API object (via KIM_API_allocate() or
# KIM_API_set_data()) before the KIM_API_model_compute() function is called.
# The Simulator is free to change this pointer at any time.
#
# Name                      Type         Unit               Shape
#
hessian                     double       pressure           [numberOfParticles,numberOfParticles,3,3]

################################################################################
#
# The MODEL_PARAMETERS section
#
################################################################################

MODEL_PARAMETERS:

################################################################################
#
# Two types of model parameters are allowed (the Unit and Requirements strings
# are ignored for MODEL_PARAMETER lines):
#
# If supported, a Model must allocate memory for these arguments and register
# it in the KIM API object (via KIM_API_set_data()) during the
# KIM_API_model_init() function call.  The Model may change these pointers
# during any call to KIM_API_model_reinit().  However, the Model must be sure
# to account for any changes made by the Simulator to the existing parameter
# values before deallocating the parameter memory.  The Model must deallocate
# the parameter memory during the call to KIM_API_model_destroy().
#
# 1) PARAM_FIXED_<label> : A parameter that should not be changed by the
#                          Simulator.  A `fixed parameter' may also be used by
#                          the Model for persistent storage between calls to
#                          the Model's compute routine and/or as local memory
#                          space to avoid the overhead of memory
#                          allocation/deallocation during each execution of the
#                          compute routine.  However, this storage should not
#                          depend on the content provided by the Simulator.
#                          For persistent storage of this type the Model Buffer
#                          should be used.
#
# 2) PARAM_FREE_<label> :  A parameter that may be changed by the Simulator
#                          (which must then call the KIM_API_model_reinit()
#                          function to inform the Model that its parameters
#                          have changed).
#
# In the above <label> is an arbitrary string of alphanumeric characters and
# the underscore (`_') character.
#
#
# IMPORTANT NOTE: It is important to stress that a Model may not store data in
# static memory since it may be called with different KIM API objects.  Any
# information that should persist between calls must be stored in the KIM API
# object.  Fixed parameters may be used for this purpose as noted above.
#
# Examples
#
# Name                      Type         Unit               Shape
#
# PARAM_FREE_Sigma          double       length             []
# PARAM_FREE_Epsilon        double       energy             []
# PARAM_FIXED_LJshift       double       energy             []
#
# In this example `PARAM_FIXED_LJshift' is a shift that brings the
# Lennard-Jones potential to zero at the defined cutoff radius.
# If the Sigma or Epsilon parameters are changed by the Simulator,
# `PARAM_FIXED_LJshift' will be recomputed during required call to
# model_reinit.
#
#
################################################################################

################################################################################
#
# PARAM_FREE_cutoff : A standard free parameter that is used to store the
#                     cutoff radius of the Model.  This parameter allows a
#                     Simulator to modify a Model by changing its cutoff radius
#                     as described above.
#
# NOTE: Currently this is the only standard parameter defined by the KIM API.
#
#
# Name                      Type         Unit               Shape
#
PARAM_FREE_cutoff           double       length             []

# END of standard.kim file
